This project consists of three main parts:
2Automaton, RobinsonTiling, and Quasicrystals

1) 2Automaton

    A 2D finite automaton which follows the transition rules Jean-Paul 
    Allouche and Olivier Salon at:
    http://web.cecs.pdx.edu/~york/cs350/cs350.html.

    Run instructions:
       $ cd 2Automaton
       $ javac Automaton.java
       $ ./Automaton

    Here is an outline of Automaton.java:

    1.1) Create an nXn grid (where n is user-input) of integer pairs ordered
    from left to right and from top to bottom.  For example, if n = 4,
    create the grid:

    (0,0) (1,0) (2,0) (3,0)
    (0,1) (1,1) (2,1) (3,1)
    (0,2) (1,2) (2,2) (3,2)
    (0,3) (1,3) (2,3) (3,3)

    1.2) Convert this grid of pairs into an nXn grid of strings by converting
    each integer to its equivalent binary string, padding the left of the 
    shorter string of the pair with 0's.  Continuing with the example above,
    the grid becomes:

    (0,0)   (1,0)   (10,00) (11,00)
    (0,1)   (1,1)   (10,01) (11,01)
    (00,10) (01,10) (10,10) (11,10)
    (00,11) (01,11) (10,11) (11,11)

    1.3) Run the automaton on each pair of strings, comparing each pair of
    bits, from least significant to most significant, using the following 
    transitions, where a-d are states
    a, (0,0) -> a  | b, (0,0) -> b  | c, (0,0) -> b  |  d, (0,0) -> a
    a, (0,1) -> b  | b, (0,1) -> a  | c, (0,1) -> c  |  d, (0,1) -> d
    a, (1,0) -> b  | b, (1,0) -> a  | c, (1,0) -> c  |  d, (1,0) -> d
    a, (1,1) -> c  | b, (1,1) -> d  | c, (1,1) -> d  |  d, (1,1) -> c


    1.4) Use the function tao below to convert the final state after consuming
    all bits into a bit.

    tao(a) = tao(d) = 0
    tao(b) = tao(c) = 1

    1.5) Store the result in a new grid of bits.

    (0,0)   (1,0)   (10,00) (11,00)      0 1 1 0
    (0,1)   (1,1)   (10,01) (11,01)  ->  1 1 0 1
    (00,10) (01,10) (10,10) (11,10)  ->  1 0 1 0
    (00,11) (01,11) (10,11) (11,11)      0 1 0 0

    1.6) Map each square group of four bits to one of 16 colors, and print
    the resulting grid of colors.

2) RobinsonTiling
    
    This project uses <a href="http://processing.org">Processing</a>, a
    Java graphics environment, to recursively generate the Robinson Tiling.

    This implementation emulates the style of  
    <a href="http://demonstrations.wolfram.com/RobinsonTiling/">this
    Wolfram Demo Project</a>.

    The Robinson Tiling uses 6 unique tiles whose shape enforces a unique
    arrangement.  Using rotations and reflections, the tiles can be 
    "pieced together" following the "rules" that are given by the tiles'
    shapes.  Other indications of allowed placement could alternatively
    be used, such as a color and/or shape pattern to indicate allowed
    neighbors.

    In RobinsonTiling.pde, eight tiles are hard-coded, but two of these
    are reflections.  The implementation begins with startTile in the
    center, and recursively draws the rotated versions of startTile to
    each of its four corners, followed by the tiles in the N, S, E and W
    directions of these corner startTiles, appropriately rotated/reflected.
    Finally, the remaining tiles along the NS and EW axes are filled with
    the tiles that "fit" in the spaces.

    The size of the grid can be changed using the 'size' dropdown.

3) Quasicrystals
    
    